/**
 * ElectricityR3F - React Three Fiber electricity effect
 *
 * Declarative Three.js scene using R3F for the portal electricity animation.
 * Uses LightningStrike geometry with Bloom post-processing.
 */

import { useRef, useMemo, useEffect, useState } from 'react'
import { Canvas, useFrame } from '@react-three/fiber'
import { EffectComposer, Bloom } from '@react-three/postprocessing'
import { LightningStrike, type RayParameters } from 'three-stdlib'
import * as THREE from 'three'
import { ELECTRICITY_CONFIG } from '../constants'

interface ElectricityR3FProps {
  visible: boolean
}

interface LightningBoltProps {
  angle: number
  radius: number
  startTime: number
  isPrimary?: boolean // 8 prominent bolts vs thin secondary
  thicknessScale?: number // Multiplier for bolt thickness
  lengthScale?: number // Multiplier for bolt length
}

// Seeded random for deterministic bolt variation
function seededRandom(seed: number): number {
  const x = Math.sin(seed * 12.9898) * 43758.5453
  return x - Math.floor(x)
}

/**
 * Individual lightning bolt component
 */
function LightningBolt({
  angle,
  radius,
  startTime,
  isPrimary = true,
  thicknessScale = 1.0,
  lengthScale = 1.0,
}: LightningBoltProps) {
  const meshRef = useRef<THREE.Mesh>(null)
  const cfg = ELECTRICITY_CONFIG

  // Create LightningStrike geometry with deterministic variation based on angle
  const strike = useMemo(() => {
    const seed = angle * 1000 // Use angle as seed for variation
    const timeScaleRange = cfg.lightningTimeScaleMax - cfg.lightningTimeScaleMin
    const ramificationRange = cfg.lightningRamificationMax - cfg.lightningRamificationMin

    // Apply thickness and length scales
    const effectiveRadius = radius * lengthScale
    const r0 = cfg.lightningRadius0 * thicknessScale
    const r1 = cfg.lightningRadius1 * thicknessScale

    const rayParams: RayParameters = {
      sourceOffset: new THREE.Vector3(0, 0, 0),
      destOffset: new THREE.Vector3(
        Math.cos(angle) * effectiveRadius,
        Math.sin(angle) * effectiveRadius,
        0
      ),
      radius0: r0,
      radius1: r1,
      minRadius: cfg.lightningMinRadius,
      maxIterations: cfg.lightningMaxIterations,
      isEternal: true,
      timeScale: cfg.lightningTimeScaleMin + seededRandom(seed) * timeScaleRange,
      propagationTimeFactor: 0.1,
      vanishingTimeFactor: 0.9,
      subrayPeriod: cfg.lightningSubrayPeriod,
      subrayDutyCycle: cfg.lightningSubrayDutyCycle,
      maxSubrayRecursion: cfg.lightningMaxSubrayRecursion,
      ramification: Math.floor(
        cfg.lightningRamificationMin + seededRandom(seed + 1) * ramificationRange
      ),
      recursionProbability: cfg.lightningRecursionProbability,
      roughness: cfg.lightningRoughness,
      straightness: cfg.lightningStraightness,
    }
    return new LightningStrike(rayParams)
  }, [angle, radius, cfg, lengthScale, thicknessScale])

  // Animation loop
  useFrame((state) => {
    const elapsed = Date.now() - startTime
    const time = state.clock.getElapsedTime()

    // Update lightning geometry
    strike.update(time)

    // Calculate intensity (fade in/out over 8 seconds - Iter 42)
    let intensity: number
    if (elapsed < 400) {
      intensity = 0.3 + (elapsed / 400) ** 2 * 0.7
    } else if (elapsed < 7400) {
      intensity = 1
    } else if (elapsed < 8000) {
      intensity = 1 - ((elapsed - 7400) / 600) ** 2
    } else {
      intensity = 0
    }

    // Surge cycle
    const elapsedSec = elapsed / 1000
    const cyclePos = (elapsedSec % cfg.surgeCycleDuration) / cfg.surgeCycleDuration
    let surge: number
    if (cyclePos < cfg.surgeBuildPhase) {
      surge =
        cfg.surgeBaseBrightness +
        (cfg.surgePeakBrightness - cfg.surgeBaseBrightness) * (cyclePos / cfg.surgeBuildPhase) ** 2
    } else if (cyclePos < cfg.surgePeakPhase) {
      surge = cfg.surgePeakBrightness
    } else {
      surge =
        cfg.surgePeakBrightness -
        (cfg.surgePeakBrightness - cfg.surgeBaseBrightness) *
          ((cyclePos - cfg.surgePeakPhase) / (1 - cfg.surgePeakPhase))
    }

    // Update material
    if (meshRef.current) {
      const mat = meshRef.current.material as THREE.MeshBasicMaterial
      mat.opacity = intensity * surge
    }
  })

  // Cleanup
  useEffect(() => {
    return () => {
      strike.dispose()
    }
  }, [strike])

  // Primary bolts: darker gold (coreColor)
  // Secondary bolts: even darker amber (outerColor) - blend into background
  // Iter 39: Much lower opacity to prevent brightness blowout
  const boltColor = isPrimary
    ? new THREE.Color(cfg.coreColor[0], cfg.coreColor[1], cfg.coreColor[2])
    : new THREE.Color(cfg.outerColor[0], cfg.outerColor[1], cfg.outerColor[2])
  const boltOpacity = isPrimary ? 0.45 : 0.2 // Iter 40: Even lower opacity

  return (
    <mesh ref={meshRef} geometry={strike}>
      <meshBasicMaterial
        color={boltColor}
        transparent
        opacity={boltOpacity}
        side={THREE.DoubleSide}
        depthWrite={false}
        blending={THREE.AdditiveBlending}
      />
    </mesh>
  )
}

/**
 * Plasma background glow - supports multiple layers at different depths
 */
interface PlasmaProps {
  startTime: number
  zDepth?: number // z-position for layering
  noiseOffset?: number // Offset for noise variation
  opacity?: number // Layer opacity multiplier
  innerColor?: [number, number, number] // Custom inner color
  outerColor?: [number, number, number] // Custom outer color
}

function PlasmaBackground({
  startTime,
  zDepth = -0.5,
  noiseOffset = 0,
  opacity = 1.0,
  innerColor,
  outerColor,
}: PlasmaProps) {
  const meshRef = useRef<THREE.Mesh>(null)
  const materialRef = useRef<THREE.ShaderMaterial>(null)
  const cfg = ELECTRICITY_CONFIG

  // Use custom colors or fall back to config
  const inner = innerColor || cfg.plasmaInner
  const outer = outerColor || cfg.plasmaOuter

  const uniforms = useMemo(
    () => ({
      u_time: { value: 0 },
      u_intensity: { value: 1.0 },
      u_innerColor: { value: new THREE.Vector3(...inner) },
      u_outerColor: { value: new THREE.Vector3(...outer) },
      u_noiseOffset: { value: noiseOffset },
      u_opacity: { value: opacity },
    }),
    [inner, outer, noiseOffset, opacity]
  )

  useFrame((state) => {
    const elapsed = Date.now() - startTime

    // Intensity calculation - 8 second duration (Iter 42)
    let intensity: number
    if (elapsed < 400) {
      intensity = 0.3 + (elapsed / 400) ** 2 * 0.7
    } else if (elapsed < 7400) {
      intensity = 1
    } else if (elapsed < 8000) {
      intensity = 1 - ((elapsed - 7400) / 600) ** 2
    } else {
      intensity = 0
    }

    // Update uniforms via material ref to avoid immutability issues
    if (materialRef.current) {
      materialRef.current.uniforms.u_time.value = state.clock.getElapsedTime()
      materialRef.current.uniforms.u_intensity.value = intensity
    }
  })

  return (
    <mesh ref={meshRef} position={[0, 0, zDepth]}>
      <circleGeometry args={[2.5, 64]} />
      <shaderMaterial
        ref={materialRef}
        transparent
        depthWrite={false}
        blending={THREE.AdditiveBlending}
        uniforms={uniforms}
        vertexShader={`
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `}
        fragmentShader={`
          uniform float u_time;
          uniform float u_intensity;
          uniform vec3 u_innerColor;
          uniform vec3 u_outerColor;
          uniform float u_noiseOffset;
          uniform float u_opacity;
          varying vec2 vUv;

          float hash(vec2 p) {
            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
          }

          float noise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);
            float a = hash(i);
            float b = hash(i + vec2(1.0, 0.0));
            float c = hash(i + vec2(0.0, 1.0));
            float d = hash(i + vec2(1.0, 1.0));
            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
          }

          void main() {
            vec2 centered = vUv - 0.5;
            float dist = length(centered) * 2.0;
            // Iter 37: Softer falloff for more amber fill
            float falloff = 1.0 - smoothstep(0.0, 1.2, dist);
            falloff = pow(falloff, 1.3); // Softer = more fill

            // Iter 41: More patchy, less uniform - break up the surface
            vec2 offsetCentered = centered + u_noiseOffset;
            float n1 = noise(offsetCentered * 2.5 + u_time * 0.15);
            float n2 = noise(offsetCentered * 5.0 - u_time * 0.1) * 0.7;
            float n3 = noise(offsetCentered * 10.0 + u_time * 0.08) * 0.4;
            float n4 = noise(offsetCentered * 20.0 - u_time * 0.05) * 0.2; // Fine detail
            float n = (n1 + n2 + n3 + n4) / 2.3;

            // Strong color variation for patchiness
            float colorVar = noise(offsetCentered * 1.5 + u_time * 0.03);
            vec3 color = mix(u_outerColor, u_innerColor, falloff * (0.5 + colorVar * 0.5));

            // Patchy alpha - use noise to create holes/gaps
            float patchiness = smoothstep(0.3, 0.7, n); // Creates patches
            float alpha = falloff * 0.6 * u_intensity * patchiness * u_opacity;

            gl_FragColor = vec4(color, alpha);
          }
        `}
      />
    </mesh>
  )
}

/**
 * Main electricity scene with all lightning bolts
 */
function ElectricityScene({ startTime }: { startTime: number }) {
  const cfg = ELECTRICITY_CONFIG
  const numBolts = cfg.numMainBolts
  const portalRadius = cfg.r3fPortalRadius

  // 10 prominent primary bolts + remaining thin/short secondary bolts
  const NUM_PRIMARY = 10

  const bolts = useMemo(() => {
    return Array.from({ length: numBolts }, (_, i) => {
      const angle = (i / numBolts) * Math.PI * 2
      const seed = i * 137.5

      // Every Nth bolt is primary (evenly spaced)
      const spacing = numBolts / NUM_PRIMARY
      const isPrimary = i % Math.round(spacing) === 0 && Math.floor(i / spacing) < NUM_PRIMARY

      // Secondary bolts: thin, VERY varied lengths, darker
      const thicknessScale = isPrimary ? 1.3 : 0.15 + seededRandom(seed) * 0.25 // 0.15-0.4x (thinner)
      const lengthScale = isPrimary ? 1.0 : 0.2 + seededRandom(seed + 1) * 0.5 // 0.2-0.7x (more varied, some very short)

      return { angle, isPrimary, thicknessScale, lengthScale }
    })
  }, [numBolts])

  return (
    <>
      {/* Camera */}
      <perspectiveCamera position={[0, 0, 5]} />

      {/* Dark but GLOWING plasma - near-black outer, BRIGHTER inner glow for luminosity contrast */}
      {/* Layer 1: Deep base - warm ember glow from darkness */}
      <PlasmaBackground
        startTime={startTime}
        zDepth={-2.0}
        noiseOffset={0}
        opacity={0.65}
        innerColor={[0.28, 0.12, 0.04]} // Brighter warm glow
        outerColor={[0.02, 0.008, 0.004]} // Even darker outer
      />
      {/* Layer 2: Rich amber glow */}
      <PlasmaBackground
        startTime={startTime}
        zDepth={-1.4}
        noiseOffset={0.7}
        opacity={0.55}
        innerColor={[0.3, 0.14, 0.04]} // Richer amber glow
        outerColor={[0.025, 0.01, 0.006]} // Near black
      />
      {/* Layer 3: Hot orange core glow */}
      <PlasmaBackground
        startTime={startTime}
        zDepth={-1.0}
        noiseOffset={1.4}
        opacity={0.5}
        innerColor={[0.35, 0.16, 0.05]} // Hot orange - brighter!
        outerColor={[0.03, 0.012, 0.008]} // Near black
      />
      {/* Layer 4: Golden mid glow */}
      <PlasmaBackground
        startTime={startTime}
        zDepth={-0.6}
        noiseOffset={2.1}
        opacity={0.45}
        innerColor={[0.32, 0.15, 0.05]} // Golden glow
        outerColor={[0.025, 0.01, 0.008]} // Near black
      />
      {/* Layer 5: Red-orange accent highlights */}
      <PlasmaBackground
        startTime={startTime}
        zDepth={-0.2}
        noiseOffset={2.8}
        opacity={0.4}
        innerColor={[0.28, 0.1, 0.06]} // Red-orange accent
        outerColor={[0.03, 0.015, 0.012]} // Near black with red warmth
      />

      {/* Lightning bolts - 8 primary (prominent) + secondary (thin/short/dim) */}
      {bolts.map((bolt, i) => (
        <LightningBolt
          key={i}
          angle={bolt.angle}
          radius={portalRadius}
          startTime={startTime}
          isPrimary={bolt.isPrimary}
          thicknessScale={bolt.thicknessScale}
          lengthScale={bolt.lengthScale}
        />
      ))}

      {/* Post-processing */}
      <EffectComposer>
        <Bloom
          intensity={cfg.r3fBloomIntensity}
          luminanceThreshold={cfg.r3fBloomLuminanceThreshold}
          luminanceSmoothing={cfg.r3fBloomLuminanceSmoothing}
          radius={cfg.r3fBloomRadius}
        />
      </EffectComposer>
    </>
  )
}

/**
 * Wrapper that tracks visibility changes
 */
function ElectricityWrapper({ startTime }: { startTime: number }) {
  return (
    <Canvas
      gl={{ alpha: true, antialias: true, preserveDrawingBuffer: true }}
      camera={{ position: [0, 0, 5], fov: 45 }}
      style={{ background: 'transparent' }}
    >
      <ElectricityScene startTime={startTime} />
    </Canvas>
  )
}

/**
 * Electricity effect component using React Three Fiber
 *
 * Uses a stable key/startTime pair that only updates when transitioning to visible.
 * The Canvas persists for the full effect duration without flickering.
 */
export function ElectricityR3F({ visible }: ElectricityR3FProps) {
  // State for canvas instance (key + startTime captured together)
  const [instance, setInstance] = useState<{ key: number; startTime: number } | null>(null)
  const wasVisibleRef = useRef(false)

  // Handle visibility transitions with deferred state update
  useEffect(() => {
    if (visible && !wasVisibleRef.current) {
      // Becoming visible - capture startTime NOW, defer state update
      const now = Date.now()
      const timer = setTimeout(() => {
        setInstance({ key: now, startTime: now })
      }, 0)
      wasVisibleRef.current = visible
      return () => clearTimeout(timer)
    } else if (!visible && wasVisibleRef.current) {
      // Becoming hidden - clear instance
      const timer = setTimeout(() => {
        setInstance(null)
      }, 0)
      wasVisibleRef.current = visible
      return () => clearTimeout(timer)
    }
    wasVisibleRef.current = visible
    return undefined
  }, [visible])

  // Don't render until we have an instance
  if (!visible || !instance) return null

  return (
    <div
      style={{
        position: 'absolute',
        left: '50%',
        top: '50%',
        transform: 'translate(-50%, -50%)',
        width: 'calc(min(100%, 100vh - 40px) * 0.78)',
        height: 'calc(min(100%, 100vh - 40px) * 0.78)',
        borderRadius: '50%',
        overflow: 'hidden',
        zIndex: 27,
        pointerEvents: 'none',
      }}
    >
      <ElectricityWrapper key={instance.key} startTime={instance.startTime} />
    </div>
  )
}
